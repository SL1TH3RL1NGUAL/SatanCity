# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# APIsec addresses the critical need to secure APIs before they reach production.
# APIsec provides the industry’s only automated and continuous API testing platform that uncovers security vulnerabilities and logic flaws in APIs.
# Clients rely on APIsec to evaluate every update and release, ensuring that no APIs go to production with vulnerabilities.

# How to Get Started with APIsec.ai
# 1. Schedule a demo at https://www.apisec.ai/request-a-demo .
#
# 2. Register your account at https://cloud.apisec.ai/#/signup .
#
# 3. Register your API . See the video (https://www.youtube.com/watch?v=MK3Xo9Dbvac) to get up and running with APIsec quickly.
#
# 4. Get GitHub Actions scan attributes from APIsec Project -> Configurations -> Integrations -> CI-CD -> GitHub Actions
#
# apisec-run-scan
#
# This action triggers the on-demand scans for projects registered in APIsec.
# If your GitHub account allows code scanning alerts, you can then upload the sarif file generated by this action to show the scan findings.
# Else you can view the scan results from the project home page in APIsec Platform.
# The link to view the scan results is also displayed on the console on successful completion of action.

# This is a starter workflow to help you get started with APIsec-Scan Actions

name: APIsec

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  # Customize trigger events based on your DevSecOps processes.
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: '30 9 * * 1'

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:


permissions:
  contents: read

jobs:

  Trigger_APIsec_scan:
    permissions:
      security-events: write # for github/codeql-action/upload-sarif to upload SARIF results
      actions: read # only required for a private repository by github/codeql-action/upload-sarif to get the Action run status
    runs-on: ubuntu-latest

    steps:
       - name: APIsec scan
         uses: apisec-inc/apisec-run-scan@025432089674a28ba8fb55f8ab06c10215e772ea
         with:
          # The APIsec username with which the scans will be executed
          apisec-username: ${{ secrets.apisec_username }}
          # The Password of the APIsec user with which the scans will be executed
          apisec-password: ${{ secrets.apisec_password}}
          # The name of the project for security scan
          apisec-project: "VAmPI"
          # The name of the sarif format result file The file is written only if this property is provided.
          sarif-result-file: "apisec-results.sarif"
       - name: Import results
         uses: github/codeql-action/upload-sarif@v3
         with:
          sarif_file: ./apisec-results.sarif

          import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as p;

/// Represents a single anomaly match found within a file.
class AnomalyMatch {
  final String pattern;
  final int count;

  AnomalyMatch({required this.pattern, required this.count});

  factory AnomalyMatch.fromJson(Map<String, dynamic> json) {
    return AnomalyMatch(
      pattern: json['pattern'] as String,
      count: json['count'] as int,
    );
  }
}

/// Represents the results of an anomaly scan for a specific file.
class AnomalyResult {
  final String file;
  final List<AnomalyMatch> matches;

  AnomalyResult({required this.file, required this.matches});

  factory AnomalyResult.fromJson(Map<String, dynamic> json) {
    final matchesJson = json['matches'] as List<dynamic>?;
    final matches = matchesJson != null
        ? matchesJson
            .map((e) => AnomalyMatch.fromJson(e as Map<String, dynamic>))
            .toList()
        : <AnomalyMatch>[];
    return AnomalyResult(
      file: json['file'] as String,
      matches: matches,
    );
  }
}

/// Represents a single anomaly capsule, or a quarantined anomaly ledger entry.
class AnomalyCapsule {
  final DateTime? timestamp;
  final String verdict;
  final List<AnomalyResult> results;
  final String? hashSeal;
  final String fileName; // Name of the JSON file this capsule was parsed from

  AnomalyCapsule({
    this.timestamp,
    required this.verdict,
    required this.results,
    this.hashSeal,
    required this.fileName,
  });

  factory AnomalyCapsule.fromJson(Map<String, dynamic> json,
      {required String fileName}) {
    DateTime? parsedTimestamp;
    try {
      final timestampStr = json['timestamp'] as String?;
      if (timestampStr != null) {
        parsedTimestamp = DateTime.parse(timestampStr).toUtc();
      }
    } catch (_) {
      // Ignore parsing errors, timestamp will remain null
    }

    final resultsJson = json['results'] as List<dynamic>?;
    final results = resultsJson != null
        ? resultsJson
            .map((e) => AnomalyResult.fromJson(e as Map<String, dynamic>))
            .toList()
        : <AnomalyResult>[];

    return AnomalyCapsule(
      timestamp: parsedTimestamp,
      verdict: json['verdict'] as String? ?? 'UNKNOWN_VERDICT',
      results: results,
      hashSeal: json['hash_seal'] as String?,
      fileName: fileName,
    );
  }
}

const String _quarantineDir = 'quarantine';
const String _outputDir = 'docs';
const String _outputFileName = 'index.html';

Future<void> main() async {
  final quarantineDirectory = Directory(_quarantineDir);
  final outputDirectory = Directory(_outputDir);

  if (!await quarantineDirectory.exists()) {
    stderr.writeln('Error: Quarantine directory "$_quarantineDir" not found.');
    stderr.writeln('Please create it and place anomaly JSON files inside.');
    exitCode = 1;
    return;
  }

  try {
    if (!await outputDirectory.exists()) {
      await outputDirectory.create(recursive: true);
    }

    final List<FileSystemEntity> entities = await quarantineDirectory.list().toList();
    final List<File> jsonFiles = entities
        .whereType<File>()
        .where((file) => p.basename(file.path).startsWith('anomaly_') && file.path.endsWith('.json'))
        .toList();

    jsonFiles.sort((a, b) => p.basename(a.path).compareTo(p.basename(b.path)));

    final List<AnomalyCapsule> anomalies = [];
    for (final file in jsonFiles) {
      try {
        final content = await file.readAsString();
        final jsonMap = jsonDecode(content) as Map<String, dynamic>;
        anomalies.add(AnomalyCapsule.fromJson(jsonMap, fileName: p.basename(file.path)));
      } on FormatException catch (e) {
        stderr.writeln('Warning: Failed to parse JSON from ${file.path}: $e');
      } on FileSystemException catch (e) {
        stderr.writeln('Warning: Failed to read file ${file.path}: $e');
      } catch (e) {
        stderr.writeln('Warning: An unexpected error occurred while processing ${file.path}: $e');
      }
    }

    final htmlContent = _buildTempleWallHtml(anomalies);
    final outputFile = File(p.join(outputDirectory.path, _outputFileName));
    await outputFile.writeAsString(htmlContent);

    stdout.writeln('Temple Wall generated successfully at ${outputFile.path}');
  } on Exception catch (e) {
    stderr.writeln('An error occurred during Temple Wall generation: $e');
    exitCode = 1;
  }
}

/// Builds the complete HTML content for the Temple Wall.
String _buildTempleWallHtml(List<AnomalyCapsule> anomalies) {
  final StringBuffer htmlBuffer = StringBuffer();

  htmlBuffer.writeln('''<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Temple Wall – Spectral Tears Ledger</title>
<style>
body { font-family: system-ui, sans-serif; background:#050711; color:#f5f5f5; margin: 0; padding: 20px; }
h1 { text-align:center; color:#e0e0e0; margin-bottom: 10px; }
p { text-align:center; color:#aaa; margin-top: 0; }
.card { border:1px solid #2a2a2a; border-radius: 8px; margin:1.5rem auto; padding:1.5rem; max-width:800px; background:#0b0f1c; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: transform 0.2s ease-in-out; }
.card:hover { transform: translateY(-3px); }
.card h2 { margin-top:0; color:#c7d2e0; }
.tag { display:inline-block; padding:0.2rem 0.6rem; margin-right:0.4rem; margin-bottom:0.4rem; border-radius:4px; font-size:0.85rem; font-weight: 600; text-transform: uppercase; }
.tag-neg { background:#7b1e3a; color:#ffe0e0; }
.tag-vinc { background:#234b7b; color:#e0f0ff; }
.meta { font-size:0.85rem; color:#aaa; margin-bottom:0.5rem; line-height: 1.4;}
.meta span { font-weight: bold; color: #bbb; }
</style>
</head>
<body>
<h1>Temple Wall of Spectral Tears</h1>
<p>Quarantined anomalies from the recovery/ ledger (append-only).</p>
''');

  for (final a in anomalies) {
    final timestamp = a.timestamp?.toIso8601String() ?? 'UNKNOWN';
    final verdict = a.verdict;
    final hashSeal = a.hashSeal ?? 'UNSEALED';

    final List<String> vincs = [];
    final Set<String> classes = {};

    for (final r in a.results) {
      for (final m in r.matches) {
        final p = m.pattern;
        if (p.startsWith('VINC-')) {
          vincs.add(p);
        } else {
          classes.add(p);
        }
      }
    }

    htmlBuffer.writeln('<div class="card">');
    htmlBuffer.writeln('<div class="meta"><span>Capsule:</span> ${a.fileName}</div>');
    htmlBuffer.writeln('<h2>$verdict</h2>');
    htmlBuffer.writeln('<div class="meta"><span>Timestamp:</span> $timestamp</div>');
    htmlBuffer.writeln('<div class="meta"><span>Seal:</span> $hashSeal</div>');

    if (vincs.isNotEmpty) {
      htmlBuffer.writeln('<div><span>VINC Spine(s):</span> ');
      for (final v in vincs) {
        htmlBuffer.writeln('<span class="tag tag-vinc">$v</span>');
      }
      htmlBuffer.writeln('</div>');
    }
    if (classes.isNotEmpty) {
      htmlBuffer.writeln('<div><span>Anomaly Classes:</span> ');
      for (final c in classes) {
        htmlBuffer.writeln('<span class="tag tag-neg">$c</span>');
      }
      htmlBuffer.writeln('</div>');
    }
    htmlBuffer.writeln('</div>');
  }

  htmlBuffer.writeln('''</body>
</html>''');

  return htmlBuffer.toString();
}
